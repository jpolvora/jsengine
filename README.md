# jsengine
The simple, faster and super lightweight Javascript template engine for Node.

# DOCUMENTATION OUTDATED. SORRY. I WILL UPDATE IT IN A FEW DAYS.


### Installation
```
npm install --save jpolvora/jsengine
```
See the /demo folder for an express app running. Check the configuration in `app.js` and the views folder for layout structure. The application was generated by the express generator, configured to run `jsengine`.

### Docs: coming soon

# Example
```js
const JsEngine = require('jsengine');

const template = `
<html>
  <body><%$model.message%></body>
</html>
`;

const options = new {
    cache: true
}

let engine = new JsEngine(opts);

let compiledTemplate = engine.compile(template);
let html = compiledTemplate({ message: 'hello world!' });
console.log(html);
```

# The basics
JsEngine is based on layout structure of .NET Razor View Engine. If you ever has worked with Razor Pages, you are already familiar with `@Layout="_Layout.cshtml"`, `@RenderSection("sectionanme")`, `@RenderPartial("partial-page")` and so on.

The difference is that in this engine you must use HTML comments to insert layout directives. The directive syntax is:
```html
<!--directive:parameter1:parameter2-->
```
# Options
Currently the defaults are:
```js
self.jsengineconfig = {
    cache: true, //will cache the templates as functions, based on the name of the main file. Recommended in production environments
    pretty: true, //will pretty the html output
    views: '' //this is the views base directory
}
```

# Interface
Currently, the available instance methods are:

`generateTemplate`: Will run the layout and generate the full template as string, without compiling and without trying hit the cache.

`compile`: Will generate a function that can be cached and reused. the function must receive an object as the model. `compiledTemplate(model)`

`render`: A helper method that can be used to compile and execute a template, returning the final HTML for output to browser.

`express`: This is the method that express app needs to call when using as the viewengine.
 

# Directives
`<!--renderbody-->` is a special directive used in layout pages (master pages) as a placeholder for the current page content.

`layout.html`
```html
<html>
    <body>
    <h1>Hello, I'm the masterpage.</h1>
    <!--renderbody-->
    </body>
</html>
```
From content pages you will use the `<!--layout:/path/to/layout-->` directive  at first line. The parameter after `:` is the filename that the page will use as the master page. The syntax is:
```html 
<!--layout:/path/to/filename-->
```
`index.html`
```html
<!--layout:layout.html-->
<div>
    <p>Hello, I'm the content page.</p>
</div>
```

The **rendersection** directive
This will be used when you have a section in layout page with a default content but the content page can override this content.
Syntax:
```html
<!--rendersection:section-name:default-file.html-->
```

Then you can use optionally in content pages the **section** directive in order to override

The **section** directive
This directive can be used to override an existing *rendersection* directive in the layout definition.
```html
<!--section:section-name:override-file.html-->
```

The **renderpartial** directive
This directive will work just like an include: Will insert the content of an external html file into current position.
```html
<!--renderpartial:partial-filename.html-->
```
The template engine after all will concatenate all pieces of files at once and then it will be ready for the parser gues why, parse the Javascript syntax.

## Javascript syntax for the template engine
This template engine use `<%` to start blocks of javascript code and `%>` to end. At the end, it's like PHP blocks (opening and closing brackets )
```html
<%if (someProperty) { %>
    <div class="some-class">Some content <% someProperty %></div>
<% } %>
```